---
title: V8垃圾回收机制
date: 2019-04-24 10:57:11
summary: 
desc: 
tag: 
category: Js
---

### V8的内存限制
在一般的后端语言中，在内存的使用上没什么限制，而在Node.js中却是被限制的（64ͮ位系统下约为`1.4 GB`，32ͮ位系统下约为`0.7 GB`）。这就导致Node.js无法直接操作过大的内存操作。

造成这种问题的原因，一是V8本是为浏览器设计的，不会遇到使用大量内存的场景。二是垃圾回收机制所限，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收就需要`50毫秒`以上，做一次非增量式的垃圾回收甚至要`1秒`以上，这是前端浏览器与后端服务器都无法接受的。

当然这个限制也是可以修改的，在启动的时候传入以下参数：
```
node --max-old-space-size=1700 test.js // 单位为MB
node --max-new-space-size=1024 test.js // 单位为KB
```
`max-old-space-size`为`老生代内存空间`，主要存放`存活时间较长或常驻内存对象`
`max-new-space-size`为`新生代内存空间`，主要存放`存活时间较短的对象`
这两个参数在V8初始化时生效，`一旦生效不可改变`，这意味着V8使用的内存无法根据使用情况自动扩充。

> 补充：<br>
> 默认情况下<br>
> 老生代内存空间 在64位系统上为1464MB，32位系统上为732MB<br>
> 新生代内存空间 在64位系统上为32MB，32位系统上为16MB

### 新生代垃圾回收
新生代内存中主要通过 Scavenge 算法（直译捡垃圾吃的算法，手动滑稽）进行， Scavenge 算法具体又使用到 Cheney 算法。其将堆内存一分为二，每一部分空间称为semispace。这两个空间一个处于使用中（我们称为FROM空间），另一个处于闲置状态（称为TO空间）。分配对象时是在FROM空间中进行分配。

这张是我画的整个过程：

![V8新生代垃圾回收机制](https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/V8-1.jpg)

Scavenge 算法的缺点是只使用了堆内存中的一般，由于该算法只夫妇只存活对象，且存活时间短的对象很少，所以Scavenge 算法在时间效率上表现优异，正式因为这些特点，所以这个算法很适合新生代垃圾回收。

### 新生代对象晋升
当一个新生代中的对象经过多次新生代回收后任然存活，它将会被认为是生命周期较长的对象，这种对象随后将会被移动到老生代中，这叫做`新生代对象晋升`。

除此之外如果`从FROM复制对象到TO空间时，TO空间的内存占比已经超过了25%`，那么这个对象将`直接晋升到老生代空间中`。

设置25%这个值是因为 Scavenge 回收完成后，当前TO空间会变为FROM空间，如果其使用率过高，会影响后续内存分配。

附两张新生代晋升判断示意图：

![V8新生代垃圾回收机制](https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/V8-2.jpg)
![V8新生代垃圾回收机制](https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/V8-3.jpg)

### 老生代垃圾回收
